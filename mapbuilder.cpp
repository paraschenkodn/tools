#include "mapbuilder.h"
//#include "buildermap.cpp"

MapBuilder::MapBuilder()
{
gridStep=0.1f;
currentmap=FLAT_MAP;

// инициализируем координатную сетку
sizefmap=10;
resizemap();
}

void MapBuilder::flatMap()
{
    // 1. открываем файл
    // 2. на его основе заполняем временную структуру данных для сцены
    // 3. устанавливаем начальный кадр во временной структуре
    // 4. переносим структуру из временной в рабочую для отображения на сцене (через критическую секцию)

    // TODO сделать выбор парсера для типа файла
    parserTRT();    // пока зададим жёсткий парсер

}

void MapBuilder::sphereMap()
{

}

void MapBuilder::newmap()
{
    filename=QFileDialog::getOpenFileName( 0, QString("Open File"));
    if (filename.isEmpty())
        return;
    //TODO проверка структуры файла

    //строим данные во временное хранилище данных
    //(если возникает ошибка сворачиваем всю работу с сообщением об ошибке)
    flatMap();
    sphereMap();
}

void MapBuilder::addPairHostsSt(QString &tr, QString &rec)  // заполняются два вектора vertices и captions
{ /// tr- трансивер (передатчик), rec - приёмник (receiver)
    // обрабатываем полученную структуру списка хостов и полученную пару типа string
        // проверяем, были ли такие IP
        int a=caption.IndexOf(tr); //OldIp  (нам надо найти последнюю пару, тогда за ней можно взять новую позицию для приёмника)
        int b=caption.IndexOf(rec); //Ip
        // проверяем совпадение пары на пару
        if ((b-a)==1||(a-b)==1){  // было, пропускаем, возможен и обратный вариант
            continue;
            }
        // проверие наличие, можно занести в массив
        caption.append(tr);
        caption.append(rec);
        // проверяем, был ли адрес передатчика приёмником или передатчиком, или он новый
        // (а если множество приёмников и передатчиков) ПЕРЕБОРОМ? нет, точка одна, смотрим направление (приёмник или передатчик)
        if (a==-1&&b==-1) { // новый приёмник и передатчик
            // такое по идее может быть только с первой парой, т.к. у нас связанные последовательно данные, но мало ли, надо как-то отработать ситуацию
            // TODO проверяем точку на координатной сетке на непустоту
            // размещаем на координатной сетке (посередине первой строки)
            if (fmap[0][sizefmap/2].isEmpty()) { // TODO делаем проверку на незанятость начала координат (если это случилось то else ...)
               fmap[0][sizefmap/2]=tr; // xyz tr
            }
            if (fmap[0][sizefmap/2+1].isEmpty()) { // TODO делаем проверку на незанятость начала координат (если это случилось то else ...)
               fmap[0][sizefmap/2+1]=tr; // xyz rec
            }
            return; // после занесения координат и других данных делать больше нечего
        }
        if (a!=-1 && b==-1) // &-побитовое И // нечет - 1, а это значит был приёмником (чёт - передатчиком)
            { // старый адрес был передатчик или приёмник (не важно, точка уже была), и новый приёмник
            // ищем точку на координатной сетке
            int r,c;
            getpointfmap(tr,r,c); // не проверяем на найденность, ибо уже она есть в captions, просто получаем координаты на сетке
            // проверяем, хватит ли размера сетки, не вылезем ли за границу (нам нужен запас +1)
            if ((r+1)==sizefmap||(c+1)==sizefmap) {
                ; ///////////////////////////
            }
            // проверяем занята ли позиция приёмника, (если да, то расширяемся) в r и c пишем координаты для новой точки
            if (!fmap[r][c+1].isEmpty()) { // занято
                // если нижележащая точка тоже занята, раздвигаемся
                if (!fmap[r+1][c+1].isEmpty()) { // тоже занято
                    // расширяемся
                    fmap.insert(r+1,QVector<QString>);
                    sizefmap++;
                    for (int i;i<sizefmap;i++){ //проходим по строкам и увеличиваем до нового размера сетки
                        fmap[i].resize(sizefmap);
                    }
                }
                // повезло, не занято, или расширились
                c++; r++;
            }
            else {  // не занято
                c=c++;
            }
            fmap[r][c]=rec; // заносим данные новой точки на координатную сетку
            return;
        }
        if (a==-1 && b!=-1)
            { // новый передатчик, и точка приёмника уже была
            //(позиции по у у других передатчиков могут быть заняты, тогда разворот пары)
            // ищем точку на координатной сетке
            int r,c;
            getpointfmap(tr,r,c); // не проверяем на найденность, ибо уже она есть в captions, просто получаем координаты на сетке
            // проверяем занята ли позиция приёмника, (если да, то расширяемся) в r и c пишем координаты для новой точки
            if (!fmap[r][c-1].isEmpty()) { // занято
                // если нижележащая точка тоже занята, раздвигаемся
            }
        }
        if (a!=-1 && b!=-1)
            { // обе точки уже были, но они отстоят далеко друг от друга !!! трудный случай (оформлять как переход?)
            // отрисовывать возвратную линию, на расстоянии полшага по сетке?
        }
}

void MapBuilder::parserTRT()
{
    /// ПАРСЕР ФАЙЛА полученного tracert (windows) ("один-файл - один маршрут!") //TODO ещё допиливать и допиливать в поте лица
    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly))
            return;
    QTextStream in(&file);
    QString line;
    //QString word;
    QRegExp rx("(([^\\[\\s]*)\\s+\\[)*((\\d{1,3}\\.){3}\\d{1,3})");
    QString Domain, Ip, OldIp("");
    while(!in.atEnd()) {
        line=in.readLine(); //
        // проверяем что строка относится к трассировке
        bool ok;
        line.mid(0,3).toInt(&ok,10);
        if (ok) { // всё в порядке, это строка трассировки
            // вычленяем из строки домен и IP
            int pos = rx.indexIn(line);
            if (pos>-1) { // это строка имеющая IP
                Domain = rx.cap(2); // если доменное имя не определилось, строка Domain будет пустой
                Ip = rx.cap(3);
                qDebug() << Domain << " " <<  Ip ;
            }
            else {  // строка без IP  * * *
                Domain=""; Ip="";
                qDebug() << "неизвестный хост";
                // TODO добавление фиктивных хостов
            }
            // добавляем данные для обработки в сырую структуру векторов (список IP устройств)
            hosts.append(OldIp);
            hosts.append(Ip);
            OldIp=Ip;
        }
      //in >> (word);
      }
    // удаляем первую пару, т.к. передатчик в ней нулевой
    if (!hosts.isEmpty()) // #1
        hosts.removeFirst();
    if (!hosts.isEmpty()) // #2
        hosts.removeFirst();
    file.close();
}

bool MapBuilder::getpointfmap(QString &data, int &row, int &col)
{
    int tmp;
    for (int i=0;fmap.size();i++)
    {
        tmp=fmap[i].indexOf(data);
        if (tmp!=-1)
        {
            col=tmp;
            row=i;
            return true;
        }
    }
    return false;
}

