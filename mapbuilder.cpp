#include "mapbuilder.h"
//#include "buildermap.cpp"

MapBuilder::MapBuilder()
{
gridStep=0.1f;
currentmap=FLAT_MAP;

// инициализируем координатную сетку
sizefmap=10;
resizemap();
}

bool MapBuilder::flatMap(bool clear)
{
  if (clear) {        // строится новая в режиме добавления или с нуля
      pairs.clear();
      fmap.clear();
      resizemap();
  }
    // 1. открываем файл
    // 2. на его основе заполняем временную структуру данных для сцены
    // 3. устанавливаем начальный кадр во временной структуре
    // 4. переносим структуру из временной в рабочую для отображения на сцене (через критическую секцию)

    // TODO сделать выбор парсера для типа файла
    parserTRT();    // пока зададим жёсткий парсер
    for (int i=0;i<hosts.size();i+=2) {
        fmapPairHostsSt(hosts[i],hosts[i+1]);
    }
    fmapToVertices();   // карту в вершины
  return true;
}

bool MapBuilder::sphereMap(bool clear)
{  
return clear;
}

void MapBuilder::newmap(bool clear)
{
    filename=QFileDialog::getOpenFileName( 0, QString("Open File"));
    if (filename.isEmpty())
        return;
    //TODO проверка структуры файла

  m_mutex.lock();
  newmapbuild=false;
    //строим данные во временное хранилище данных
    //TODO(если возникает ошибка сворачиваем всю работу (не забывая, что находимся в критической секции) с сообщением об ошибке)
    flatMap(clear);
    sphereMap(clear);

  m_mutex.unlock();
  newmapbuild=true; // карта готова, забирайте, после не забудьте скинуть на 0 (false)
  //TODO лучше оформить/дополнить это дело сигналом
}

void MapBuilder::fmapPairHostsSt(QString &tr, QString &rec)  // распределение хостов по координатной сетке (hosts хранит пары), fmap (хранит привязку хоста к карте)
{ /// tr- трансивер (передатчик), rec - приёмник (receiver)
    // обрабатываем полученную структуру списка хостов и полученную пару типа string
    // проверяем, были ли такие IP ( пустых isEmpty() не должно быть! )
    int a=pairs.indexOf(tr); //OldIp  (нам надо найти последнюю пару, тогда за ней можно взять новую позицию для приёмника)
    int b=pairs.indexOf(rec); //Ip
    // проверяем совпадение пары на пару
    if (((b-a)==1||(a-b)==1)&&a!=-1&&b!=-1){  // было, пропускаем, возможен и обратный вариант
        return;
        }
    // проверие наличие, можно занести в массив
    pairs.append(tr);
    pairs.append(rec);
    // проверяем, был ли адрес передатчика приёмником или передатчиком, или он новый
    // (а если множество приёмников и передатчиков) ПЕРЕБОРОМ? нет, точка одна, смотрим направление (приёмник или передатчик)
    if (a==-1&&b==-1) { // новый приёмник и передатчик
        // такое по идее может быть только с первой парой, и в случае добавления
        // размещаем на координатной сетке (посередине первой свободной строки)
        bool f=false;
        int i;
        for (i=0;i<sizefmap;i++) {
            if (fmap[i][(sizefmap/2)-1].isEmpty() && fmap[i][sizefmap/2].isEmpty()) {// найдено свободное место
                f=true;
                break;
            }
        }
        if (!f) { // не найдено свободное место, увеличиваем карту
            i=sizefmap;
            sizefmap++; // на одну (при необходимости можно увеличить)
            fmap.resize(sizefmap); // увеличиваем список строк (добавляется одна)
            for (int i=0;i<sizefmap;i++){ //проходим по строкам и увеличиваем до нового размера сетки (добавляется одна колонка в строке)
                fmap[i].resize(sizefmap);
            }
        }
        fmap[i][(sizefmap/2)-1]=tr; // xyz tr
        fmap[i][sizefmap/2]=rec; // xyz rec
        return; // после занесения координат и других данных делать больше нечего
    }
    if (a!=-1 && b==-1) // &-побитовое И // нечет - 1, а это значит был приёмником (чёт - передатчиком)
        { // старый адрес был передатчик или приёмник (не важно, точка уже была), и новый приёмник
        // ищем точку на координатной сетке
        int r,c;
        if (!getpointfmap(tr,r,c)) { // получаем координаты на сетке
            qWarning() << "Ошибка определения индекса. 91"; // ничего не было найдено
            return;
        }
        // проверяем, хватит ли размера сетки, не вылезем ли за границу (нам нужен запас минимум +1)
        if ((r+1)>=sizefmap||(c+1)>=sizefmap) { // уже впритык, делаем запас (можно не на +1 а на порядок, например +10)
            sizefmap++; // на одну
            fmap.resize(sizefmap); // увеличиваем список строк (добавляется одна)
            for (int i=0;i<sizefmap;i++){ //проходим по строкам и увеличиваем до нового размера сетки (добавляется одна колонка в строке)
                fmap[i].resize(sizefmap);
            }
        }
        // проверяем занята ли позиция приёмника, (если да, то расширяемся) в r и c пишем координаты для новой точки
        if (!fmap[r][c+1].isEmpty()) { // занято
            // если нижележащая точка тоже занята, раздвигаем сетку
            if (!fmap[r+1][c+1].isEmpty()) { // тоже занято
                // расширяемся
                fmap.insert(r+1, QVector<QString>() );
                sizefmap++;
                for (int i=0;i<sizefmap;i++){ //проходим по строкам и увеличиваем до нового размера сетки
                    fmap[i].resize(sizefmap);
                }
            }
            // повезло, не занято, или расширили сетку
            c++; r++;
        }
        else {  // не занято
             c++;
        }
        fmap[r][c]=rec; // заносим данные новой точки на координатную сетку
        return;
    }
    if (a==-1 && b!=-1)
        { // новый передатчик, и точка приёмника уже была
        //(позиции по у у других передатчиков могут быть заняты, тогда разворот пары)
        // ищем точку на координатной сетке
        int r,c;
        if (!getpointfmap(rec,r,c)) { // получаем координаты на сетке
            qWarning() << "Ошибка определения индекса. 128"; //ничего не было найдено
            return;
        }
        // проверяем, хватит ли размера сетки, не вылезем ли за границу (нам нужен запас минимум +1)
        if ((r+1)>=sizefmap) { // уже впритык, делаем запас (можно не на +1 а на порядок, например +10)
            sizefmap++; // на одну
            fmap.resize(sizefmap); // увеличиваем список строк (добавляется одна)
            for (int i=0;i<sizefmap;i++){ //проходим по строкам и увеличиваем до нового размера сетки (добавляется одна колонка в строке)
                fmap[i].resize(sizefmap);
            }
        }
        // проверяем, хватит ли размера сетки, не вылезем ли за границу (нам нужен запас минимум +1)
        if ((c-1)<1) { // уже впритык, делаем запас (можно не на +1 а на порядок, например +10)
            sizefmap++; // на одну
            fmap.resize(sizefmap); // увеличиваем список строк (добавляется одна)
            for (int i=0;i<sizefmap;i++){ //проходим по строкам и увеличиваем до нового размера сетки (вставляется в начало одна колонка в строке)
                fmap[i].insert(0,QString(""));
            }
        }
        // проверяем занята ли позиция нового передатчика, (если да, то расширяемся) в r и c пишем координаты для новой точки
        if (!fmap[r][c-1].isEmpty()) { // занято
            // если нижележащая точка тоже занята, раздвигаем сетку
            if (!fmap[r+1][c-1].isEmpty()) { // тоже занято
                // расширяемся
                fmap.insert(r+1, QVector<QString>() );
                sizefmap++;
                for (int i=0;i<sizefmap;i++){ //проходим по строкам и увеличиваем до нового размера сетки
                    fmap[i].resize(sizefmap);
                }
            }
            // повезло, не занято, или расширили сетку
            c--; r++;
        }
        else {  // не занято
            c--;
        }
        fmap[r][c]=tr; // заносим данные новой точки на координатную сетку
        return;
    }
    if (a!=-1 && b!=-1)
        { // обе точки уже были, но они отстоят далеко друг от друга !!! трудный случай (оформлять как переход?)
        // отрисовывать возвратную линию, на расстоянии полшага по сетке?
    }
}

void MapBuilder::fmapToVertices() // сброс данных в координаты вершин и списка надписей (vertices, captions)
{
    // за 0 берем середину сетки координат sizefmap/2 (целочисленное деление)
    int offset=sizefmap/2;
    vertices.resize(pairs.size()*3); //
    captions.resize(pairs.size());
    //vertices.clear();
    int r, c;
    for (int i=0;i<pairs.size();i++) {
        if (!getpointfmap(pairs[i],r,c)) {
            continue;
        }
        vertices[i*3]=(c-offset)*gridStep; //x - это колонка  (единица по координатной сетке это 1 gridStep в системе координат)
        vertices[(i*3)+1]=(-r)*gridStep; //y - это строка
        vertices[(i*3)+2]=0; //z
        // если точка уже была, то у неё не должно быть надписи, чтобы не отображалась дважды...
        if (pairs.indexOf(pairs[i])!=i) {   // повторение точки
            captions[i]="";
        }
        else { // это первая точка
            captions[i]=pairs[i];
        }
    }
}

void MapBuilder::parserTRT()
{
    /// ПАРСЕР ФАЙЛА полученного tracert (windows) ("один-файл - один маршрут!") //TODO ещё допиливать и допиливать в поте лица
    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly))
            return;
    QTextStream in(&file);
    QString line;
    //QString word;
    QRegExp rx("(([^\\[\\s]*)\\s+\\[)*((\\d{1,3}\\.){3}\\d{1,3})");
    QString Domain, Ip, OldIp("");
    hosts.clear();
    while(!in.atEnd()) {
        line=in.readLine(); //
        // проверяем что строка относится к трассировке
        bool ok;
        line.mid(0,3).toInt(&ok,10);
        if (ok) { // всё в порядке, это строка трассировки
            // вычленяем из строки домен и IP
            int pos = rx.indexIn(line);
            if (pos>-1) { // это строка имеющая IP
                Domain = rx.cap(2); // если доменное имя не определилось, строка Domain будет пустой
                Ip = rx.cap(3);
                //qDebug() << Domain << " " <<  Ip ;
            }
            else {  // строка без IP  * * *
                Domain="*"; Ip="*";   //( пустых isEmpty() не должно быть! )
                //qDebug() << "неизвестный хост";
                // TODO добавление фиктивных хостов
            }
            // добавляем данные для обработки в сырую структуру векторов (список IP устройств)
            hosts.append(OldIp);
            hosts.append(Ip);
            OldIp=Ip;
        }
      //in >> (word);
      }
    // удаляем первую пару, т.к. передатчик в ней нулевой
    if (!hosts.isEmpty()) // #1
        hosts.removeFirst();
    if (!hosts.isEmpty()) // #2
        hosts.removeFirst();
    file.close();
}

bool MapBuilder::getpointfmap(QString &data, int &row, int &col)
{
    int tmp;
    for (int i=0;i<fmap.size();i++) // проверяем размер по индексу строк
    {
        tmp=fmap[i].indexOf(data);  // это индекс колонки
        if (tmp!=-1)
        {
            col=tmp;
            row=i;
            return true;
        }
    }
    // ничего не было найдено, на всякий случай вернём нулевой индекс
    col=0; row=0;
    return false;
}

